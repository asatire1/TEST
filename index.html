<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ecosystem Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
        }

        .container {
            background: #334155;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            max-width: 800px;
            width: 100%;
            max-height: calc(100vh - 20px);
            display: flex;
            flex-direction: column;
        }

        h1 {
            color: #f1f5f9;
            text-align: center;
            margin-bottom: 5px;
            font-size: 20px;
            line-height: 1.2;
        }

        .subtitle {
            color: #94a3b8;
            text-align: center;
            margin-bottom: 10px;
            font-size: 12px;
        }

        /* Header with buttons */
        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }

        .header-title {
            flex: 1;
            text-align: center;
        }

        .header-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .header-btn-clear {
            background: #475569;
            color: #f1f5f9;
        }

        .header-btn-clear:hover {
            background: #64748b;
        }

        .header-btn-start {
            background: #22d3ee;
            color: #0f172a;
        }

        .header-btn-start:hover {
            background: #06b6d4;
        }

        .arena-wrapper {
            background: #D3D3D3;
            border-radius: 8px;
            padding: 5px;
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }

        #arena {
            background: #D3D3D3;
            border: 1px solid #94a3b8;
            cursor: crosshair;
            image-rendering: crisp-edges;
            display: block;
            touch-action: none; /* Prevent scrolling on touch */
        }

        .info-panel {
            background: #1e293b;
            padding: 10px;
            border-radius: 8px;
            color: #f1f5f9;
            overflow-y: auto;
        }

        /* Speed Slider - Thin bar at top */
        .speed-slider-container {
            background: #0f172a;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .speed-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .speed-label {
            font-size: 10px;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .speed-value {
            font-size: 13px;
            font-weight: bold;
            color: #22d3ee;
        }

        .speed-slider-wrapper {
            position: relative;
        }

        .speed-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, #475569 0%, #22d3ee 50%, #fbbf24 100%);
            outline: none;
            cursor: pointer;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #22d3ee;
            cursor: pointer;
            border: 3px solid #0f172a;
            box-shadow: 0 2px 8px rgba(34, 211, 238, 0.5);
            transition: all 0.2s;
        }

        .speed-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 2px 12px rgba(34, 211, 238, 0.8);
        }

        .speed-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #22d3ee;
            cursor: pointer;
            border: 3px solid #0f172a;
            box-shadow: 0 2px 8px rgba(34, 211, 238, 0.5);
            transition: all 0.2s;
        }

        .speed-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 2px 12px rgba(34, 211, 238, 0.8);
        }

        .speed-markers {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            padding: 0 2px;
        }

        .speed-marker {
            font-size: 9px;
            color: #64748b;
        }

        /* Stats Bar - Combined with tool selection */
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 10px;
        }

        .stat-item {
            background: #334155;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
        }

        .stat-item:hover {
            background: #475569;
            transform: translateY(-2px);
        }

        .stat-item.active {
            border-color: #22d3ee;
            background: #1e293b;
            box-shadow: 0 0 20px rgba(34, 211, 238, 0.3);
        }

        /* Disable tool selection during gameplay */
        body.simulation-running .stat-item {
            cursor: default;
            pointer-events: none;
        }

        body.simulation-running .stat-item.active {
            border-color: transparent;
            box-shadow: none;
        }

        .stat-icon {
            font-size: 28px;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .shape-preview {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .preview-grass {
            width: 6px;
            height: 6px;
            background: #16a34a;
            border-radius: 50%;
        }

        .preview-rabbit {
            width: 16px;
            height: 16px;
            background: #3b82f6;
            border-radius: 50%;
            border: 2px solid #1d4ed8;
        }

        .preview-fox {
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 17px solid #ef4444;
        }

        .stat-label {
            font-size: 10px;
            color: #94a3b8;
            margin-bottom: 3px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 22px;
            font-weight: bold;
        }

        .grass-color { color: #16a34a; }
        .rabbit-color { color: #3b82f6; }
        .fox-color { color: #ef4444; }

        /* Time & Controls Section */
        .time-controls {
            background: #0f172a;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .time-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .day-counter {
            text-align: center;
        }

        .day-label {
            font-size: 12px;
            color: #94a3b8;
            margin-bottom: 3px;
        }

        .day-value {
            font-size: 28px;
            font-weight: bold;
            color: #22d3ee;
        }

        .timer {
            text-align: center;
        }

        .timer-label {
            font-size: 12px;
            color: #94a3b8;
            margin-bottom: 3px;
        }

        .timer-value {
            font-size: 18px;
            font-weight: bold;
            color: #cbd5e1;
        }

        .balance-indicator {
            text-align: center;
        }

        .balance-label {
            font-size: 12px;
            color: #94a3b8;
            margin-bottom: 3px;
        }

        .balance-value {
            font-size: 18px;
            font-weight: bold;
        }

        .balance-healthy { color: #22c55e; }
        .balance-warning { color: #fbbf24; }
        .balance-danger { color: #ef4444; }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #22d3ee;
            color: #0f172a;
        }

        .btn-primary:hover {
            background: #06b6d4;
        }

        .btn-secondary {
            background: #475569;
            color: #f1f5f9;
        }

        .btn-secondary:hover {
            background: #64748b;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .status {
            text-align: center;
            padding: 8px;
            background: #0f172a;
            border-radius: 6px;
            color: #22d3ee;
            font-size: 11px;
            line-height: 1.4;
        }

        @media (max-width: 600px) {
            body {
                padding: 5px;
            }

            .container {
                padding: 10px;
                border-radius: 8px;
            }
            
            h1 {
                font-size: 16px;
            }

            .subtitle {
                font-size: 10px;
                margin-bottom: 5px;
            }

            .header-btn {
                padding: 6px 10px;
                font-size: 11px;
            }

            .stat-icon {
                font-size: 24px;
            }

            .stat-value {
                font-size: 20px;
            }

            .status {
                font-size: 10px;
                padding: 6px;
            }
        }

        /* Phase-specific visibility */
        .setup-only { display: block; }
        .playing-only { display: none; }
        
        body.simulation-running .setup-only { display: none; }
        body.simulation-running .playing-only { display: block; }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #475569;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #cbd5e1;
        }

        .legend-shape {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .grass-shape {
            width: 4px;
            height: 4px;
            background: #22c55e;
            border-radius: 50%;
        }

        .rabbit-shape {
            width: 12px;
            height: 12px;
            background: #fb923c;
            border-radius: 50%;
            border: 2px solid #ea580c;
        }

        .fox-shape {
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 14px solid #ef4444;
        }

        .status {
            text-align: center;
            padding: 10px;
            background: #0f172a;
            border-radius: 6px;
            color: #22d3ee;
            font-size: 14px;
            margin-top: 10px;
        }

        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 20px;
            }
            
            .grid-info {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-bar">
            <button class="header-btn header-btn-clear setup-only" id="btnClearHeader">🗑️ Clear</button>
            <div class="header-title">
                <h1>🌍 Ecosystem Simulation</h1>
                <p class="subtitle">Create a balanced ecosystem that survives 100 days</p>
            </div>
            <button class="header-btn header-btn-start setup-only" id="btnStartHeader">▶️ Start</button>
        </div>
        
        <div class="arena-wrapper">
            <canvas id="arena"></canvas>
        </div>

        <div class="info-panel">
            <!-- Speed Slider - At the top -->
            <div class="speed-slider-container">
                <div class="speed-header">
                    <span class="speed-label">⚡ Simulation Speed</span>
                    <span class="speed-value" id="speedDisplay">1.0×</span>
                </div>
                <div class="speed-slider-wrapper">
                    <input type="range" min="0.5" max="10" step="0.5" value="1" class="speed-slider" id="speedSlider">
                </div>
                <div class="speed-markers">
                    <span class="speed-marker">0.5×</span>
                    <span class="speed-marker">1×</span>
                    <span class="speed-marker">2×</span>
                    <span class="speed-marker">5×</span>
                    <span class="speed-marker">10×</span>
                </div>
            </div>

            <!-- Combined Stats & Tool Selection -->
            <div class="stats-bar">
                <div class="stat-item active" id="statGrass" data-tool="grass">
                    <div class="stat-icon">
                        <span>🌱</span>
                        <div class="shape-preview">
                            <div class="preview-grass"></div>
                        </div>
                    </div>
                    <div class="stat-label">Grass</div>
                    <div class="stat-value grass-color" id="grassCount">0</div>
                </div>
                <div class="stat-item" id="statRabbit" data-tool="rabbit">
                    <div class="stat-icon">
                        <span>🐰</span>
                        <div class="shape-preview">
                            <div class="preview-rabbit"></div>
                        </div>
                    </div>
                    <div class="stat-label">Rabbits</div>
                    <div class="stat-value rabbit-color" id="rabbitCount">0</div>
                </div>
                <div class="stat-item" id="statFox" data-tool="fox">
                    <div class="stat-icon">
                        <span>🦊</span>
                        <div class="shape-preview">
                            <div class="preview-fox"></div>
                        </div>
                    </div>
                    <div class="stat-label">Foxes</div>
                    <div class="stat-value fox-color" id="foxCount">0</div>
                </div>
            </div>

            <!-- Time Display & Balance - Always visible -->
            <div class="time-controls">
                <div class="time-display">
                    <div class="day-counter">
                        <div class="day-label">Day</div>
                        <div class="day-value"><span id="currentDay">0</span> / 100</div>
                    </div>
                    <div class="timer">
                        <div class="timer-label">Time Elapsed</div>
                        <div class="timer-value" id="timeElapsed">00:00</div>
                    </div>
                    <div class="balance-indicator playing-only">
                        <div class="balance-label">Balance</div>
                        <div class="balance-value balance-healthy" id="balance">100%</div>
                    </div>
                </div>
            </div>

            <!-- Instructions - Only during setup -->
            <div class="status setup-only">
                💡 Click organism to select • Drag to place multiples • Try: 200 Grass : 100 Rabbits : 50 Foxes
            </div>

            <!-- Action Buttons - Only during playing phase -->
            <div class="action-buttons playing-only">
                <button class="btn btn-primary" id="btnPause">⏸️ Pause</button>
                <button class="btn btn-danger" id="btnReset">🔄 Reset</button>
            </div>
        </div>
    </div>

    <script>
        const GRID_SIZE = 64;
        const canvas = document.getElementById('arena');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameState = 'setup'; // 'setup' or 'playing'
        let selectedTool = 'grass'; // 'grass', 'rabbit', 'fox'
        let simulationSpeed = 1; // 0.5 to 10
        let isPaused = false;
        let currentDay = 0;
        let timeElapsed = 0;
        let tileSize = 0;

        // Timing
        let lastFrameTime = 0;
        let dayDuration = 30; // 30 seconds per day at 1x speed
        let animationFrameId = null;

        // Placement state
        let isPlacing = false;
        let lastPlacedTile = null;

        // Population counts
        let populations = {
            grass: 0,
            rabbits: 0,
            foxes: 0
        };

        // Organisms array
        let organisms = [];
        let nextId = 1;

        // Grass regrowth tracking
        let regrowingTiles = []; // {x, y, timer}

        // Two-layer grid system
        const grid = [];
        
        // Initialize empty grid with two layers
        function initGrid() {
            for (let y = 0; y < GRID_SIZE; y++) {
                grid[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    grid[y][x] = {
                        x: x,
                        y: y,
                        groundLayer: null,  // For grass
                        animalLayer: null   // For rabbits or foxes
                    };
                }
            }
            organisms = [];
            nextId = 1;
        }

        // Get grid coordinates from mouse/touch position
        function getGridPosition(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((clientX - rect.left) / tileSize);
            const y = Math.floor((clientY - rect.top) / tileSize);
            
            if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                return { x, y };
            }
            return null;
        }

        // Place organism at position
        function placeOrganism(x, y) {
            if (gameState !== 'setup') return;
            
            const tile = grid[y][x];
            
            // Check if we've already placed on this tile in this drag
            if (lastPlacedTile && lastPlacedTile.x === x && lastPlacedTile.y === y) {
                return;
            }
            
            if (selectedTool === 'grass') {
                // Place on ground layer
                if (tile.groundLayer === null) {
                    const organism = {
                        id: nextId++,
                        type: 'grass',
                        x: x,
                        y: y,
                        spreadTimer: 0, // Timer for spreading
                        alpha: 1 // For fade effects
                    };
                    organisms.push(organism);
                    tile.groundLayer = organism.id;
                    populations.grass++;
                }
            } else if (selectedTool === 'rabbit') {
                // Place on animal layer
                if (tile.animalLayer === null) {
                    const organism = {
                        id: nextId++,
                        type: 'rabbit',
                        x: x,
                        y: y,
                        visualX: x, // For smooth animation
                        visualY: y,
                        hungerTimer: 0, // Dies at 12 seconds
                        lifeTimer: 0, // Dies at 80 seconds naturally
                        moveTimer: 0,
                        reproductionTimer: 0,
                        targetX: x,
                        targetY: y,
                        alpha: 1, // For fade effects
                        trail: [] // Movement trail
                    };
                    organisms.push(organism);
                    tile.animalLayer = organism.id;
                    populations.rabbits++;
                }
            } else if (selectedTool === 'fox') {
                // Place on animal layer
                if (tile.animalLayer === null) {
                    const organism = {
                        id: nextId++,
                        type: 'fox',
                        x: x,
                        y: y,
                        visualX: x, // For smooth animation
                        visualY: y,
                        hungerTimer: 0, // Dies at 25 seconds
                        lifeTimer: 0, // Dies at 160 seconds naturally
                        moveTimer: 0,
                        reproductionTimer: 0,
                        alpha: 1, // For fade effects
                        trail: [] // Movement trail
                    };
                    organisms.push(organism);
                    tile.animalLayer = organism.id;
                    populations.foxes++;
                }
            }
            
            lastPlacedTile = { x, y };
            updatePopulationDisplay();
            render();
        }

        // Mouse/Touch event handlers
        function handleStart(e) {
            if (gameState !== 'setup') return;
            e.preventDefault();
            
            isPlacing = true;
            lastPlacedTile = null;
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            const pos = getGridPosition(clientX, clientY);
            if (pos) {
                placeOrganism(pos.x, pos.y);
            }
        }

        function handleMove(e) {
            if (!isPlacing || gameState !== 'setup') return;
            e.preventDefault();
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            const pos = getGridPosition(clientX, clientY);
            if (pos) {
                placeOrganism(pos.x, pos.y);
            }
        }

        function handleEnd(e) {
            isPlacing = false;
            lastPlacedTile = null;
        }

        // Add event listeners to canvas
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd);

        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchmove', handleMove);
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);

        // Update population display
        function updatePopulationDisplay() {
            document.getElementById('grassCount').textContent = populations.grass;
            document.getElementById('rabbitCount').textContent = populations.rabbits;
            document.getElementById('foxCount').textContent = populations.foxes;
        }

        // Tool selection - Click on stat boxes to select tool
        document.querySelectorAll('.stat-item').forEach(item => {
            item.addEventListener('click', function() {
                // Only allow tool selection during setup phase
                if (gameState !== 'setup') return;
                
                document.querySelectorAll('.stat-item').forEach(i => i.classList.remove('active'));
                this.classList.add('active');
                selectedTool = this.dataset.tool;
                console.log('🎯 Selected tool:', selectedTool);
            });
        });

        // Speed slider control
        const speedSlider = document.getElementById('speedSlider');
        const speedDisplay = document.getElementById('speedDisplay');
        
        speedSlider.addEventListener('input', function() {
            simulationSpeed = parseFloat(this.value);
            speedDisplay.textContent = simulationSpeed.toFixed(1) + '×';
        });

        // Start simulation
        document.getElementById('btnStartHeader').addEventListener('click', function() {
            if (populations.grass === 0 && populations.rabbits === 0 && populations.foxes === 0) {
                alert('⚠️ Please place some organisms before starting the simulation!');
                return;
            }
            gameState = 'playing';
            document.body.classList.add('simulation-running');
            lastFrameTime = 0;
            timeElapsed = 0;
            currentDay = 0;
            regrowingTiles = []; // Clear any regrowth timers
            
            // Start game loop
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(gameLoop);
            
            console.log('▶️ Simulation started');
        });

        // Pause/Resume
        document.getElementById('btnPause').addEventListener('click', function() {
            isPaused = !isPaused;
            this.textContent = isPaused ? '▶️ Resume' : '⏸️ Pause';
            
            if (!isPaused) {
                // Reset frame time to avoid large delta
                lastFrameTime = 0;
            }
        });

        // Reset
        document.getElementById('btnReset').addEventListener('click', function() {
            if (confirm('Reset the simulation and return to setup?')) {
                // Stop game loop
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                gameState = 'setup';
                document.body.classList.remove('simulation-running');
                isPaused = false;
                currentDay = 0;
                timeElapsed = 0;
                lastFrameTime = 0;
                isPlacing = false;
                lastPlacedTile = null;
                populations = { grass: 0, rabbits: 0, foxes: 0 };
                organisms = []; // Clear organisms array
                regrowingTiles = [];
                nextId = 1; // Reset ID counter
                initGrid();
                updatePopulationDisplay();
                render();
                document.getElementById('btnPause').textContent = '⏸️ Pause';
                document.getElementById('timeElapsed').textContent = '00:00';
                document.getElementById('currentDay').textContent = '0';
                console.log('🔄 Game reset');
            }
        });

        // Clear grid
        document.getElementById('btnClearHeader').addEventListener('click', function() {
            if (populations.grass === 0 && populations.rabbits === 0 && populations.foxes === 0) {
                return; // Nothing to clear
            }
            if (confirm('Clear all organisms from the grid?')) {
                populations = { grass: 0, rabbits: 0, foxes: 0 };
                organisms = []; // Clear organisms array
                regrowingTiles = [];
                nextId = 1; // Reset ID counter
                initGrid();
                updatePopulationDisplay();
                render();
                console.log('🗑️ Grid cleared');
            }
        });
        
        // Initialize empty grid with two layers
        function initGrid() {
            for (let y = 0; y < GRID_SIZE; y++) {
                grid[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    grid[y][x] = {
                        x: x,
                        y: y,
                        groundLayer: null,  // For grass
                        animalLayer: null   // For rabbits or foxes
                    };
                }
            }
        }

        // Setup canvas with responsive sizing
        function setupCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth - 10; // Minimal padding
            
            // On mobile, consider available viewport height
            const isMobile = window.innerWidth <= 600;
            const availableHeight = isMobile ? window.innerHeight * 0.45 : 9999; // Use ~45% of screen on mobile
            
            // Make canvas square and responsive
            let size = Math.min(containerWidth, 800, availableHeight); // Limit by width, max size, or available height
            
            // Ensure size is divisible by GRID_SIZE for crisp pixels
            size = Math.floor(size / GRID_SIZE) * GRID_SIZE;
            
            canvas.width = size;
            canvas.height = size;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            
            const tileSize = size / GRID_SIZE;
            
            return tileSize;
        }

        // Draw the grid with dotted lines
        function drawGrid(tileSize) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw dotted grid lines
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 0.5;
            ctx.setLineDash([2, 2]); // Dotted pattern
            
            // Vertical lines
            for (let x = 0; x <= GRID_SIZE; x++) {
                ctx.beginPath();
                ctx.moveTo(x * tileSize, 0);
                ctx.lineTo(x * tileSize, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y <= GRID_SIZE; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * tileSize);
                ctx.lineTo(canvas.width, y * tileSize);
                ctx.stroke();
            }
            
            ctx.setLineDash([]); // Reset line dash
        }

        // Draw organisms
        function drawOrganisms() {
            organisms.forEach(org => {
                // Use visualX/visualY for animals (smooth movement), regular x/y for grass
                const posX = org.visualX !== undefined ? org.visualX : org.x;
                const posY = org.visualY !== undefined ? org.visualY : org.y;
                
                const centerX = (posX + 0.5) * tileSize;
                const centerY = (posY + 0.5) * tileSize;
                
                // Draw movement trail for animals
                if (org.trail && org.trail.length > 0) {
                    ctx.strokeStyle = org.type === 'rabbit' ? 'rgba(59, 130, 246, 0.2)' : 'rgba(239, 68, 68, 0.2)';
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    
                    org.trail.forEach((point, i) => {
                        const trailX = (point.x + 0.5) * tileSize;
                        const trailY = (point.y + 0.5) * tileSize;
                        const trailAlpha = point.alpha * (org.alpha || 1);
                        
                        if (i === 0) {
                            ctx.moveTo(trailX, trailY);
                        } else {
                            ctx.globalAlpha = trailAlpha;
                            ctx.lineTo(trailX, trailY);
                        }
                    });
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                // Set alpha for fade effects
                ctx.globalAlpha = org.alpha !== undefined ? org.alpha : 1;
                
                if (org.type === 'grass') {
                    // Small darker green dot
                    ctx.fillStyle = '#16a34a';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, tileSize * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                } else if (org.type === 'rabbit') {
                    // Blue circle with border - fade if hungry
                    const isHungry = org.hungerTimer > 6;
                    const baseAlpha = org.alpha !== undefined ? org.alpha : 1;
                    ctx.fillStyle = isHungry ? '#bfdbfe' : '#3b82f6';
                    ctx.globalAlpha = isHungry ? baseAlpha * 0.6 : baseAlpha;
                    ctx.strokeStyle = '#1d4ed8';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    // Add pulse effect if just ate (hunger < 1)
                    const scale = org.hungerTimer < 1 ? 1 + (1 - org.hungerTimer) * 0.2 : 1;
                    ctx.arc(centerX, centerY, tileSize * 0.25 * scale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                } else if (org.type === 'fox') {
                    // Red triangle pointing up - fade if hungry
                    const isHungry = org.hungerTimer > 10;
                    const baseAlpha = org.alpha !== undefined ? org.alpha : 1;
                    ctx.fillStyle = isHungry ? '#fca5a5' : '#ef4444';
                    ctx.globalAlpha = isHungry ? baseAlpha * 0.6 : baseAlpha;
                    ctx.beginPath();
                    
                    // Add pulse effect if just ate (hunger < 1)
                    const scale = org.hungerTimer < 1 ? 1 + (1 - org.hungerTimer) * 0.2 : 1;
                    const size = tileSize * 0.35 * scale;
                    ctx.moveTo(centerX, centerY - size); // Top point
                    ctx.lineTo(centerX - size, centerY + size); // Bottom left
                    ctx.lineTo(centerX + size, centerY + size); // Bottom right
                    ctx.closePath();
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            });
            
            ctx.globalAlpha = 1; // Reset
        }

        // SIMULATION LOGIC

        // Grass spreading and regrowth
        function updateGrass(deltaTime) {
            const grassToAdd = [];
            
            // Fade in new grass
            organisms.forEach(org => {
                if (org.type !== 'grass') return;
                
                // Fade in effect
                if (org.alpha < 1) {
                    org.alpha = Math.min(1, org.alpha + deltaTime * 2); // Fade in over 0.5 seconds
                }
            });
            
            // Update regrowth timers
            const regrowthToProcess = [];
            regrowingTiles.forEach((tile, index) => {
                tile.timer += deltaTime;
                
                // Regrow after 15 seconds
                if (tile.timer >= 15) {
                    regrowthToProcess.push(index);
                    grassToAdd.push({ x: tile.x, y: tile.y });
                }
            });
            
            // Remove processed regrowth tiles (reverse order to avoid index issues)
            regrowthToProcess.reverse().forEach(index => {
                regrowingTiles.splice(index, 1);
            });
            
            // Grass spreading
            organisms.forEach(org => {
                if (org.type !== 'grass') return;
                
                org.spreadTimer += deltaTime;
                
                // Spread every 5 seconds
                if (org.spreadTimer >= 5) {
                    org.spreadTimer = 0;
                    
                    // Try to spread to adjacent tile
                    const directions = [
                        {dx: -1, dy: -1}, {dx: 0, dy: -1}, {dx: 1, dy: -1},
                        {dx: -1, dy: 0},                   {dx: 1, dy: 0},
                        {dx: -1, dy: 1},  {dx: 0, dy: 1},  {dx: 1, dy: 1}
                    ];
                    
                    const randomDir = directions[Math.floor(Math.random() * directions.length)];
                    const newX = org.x + randomDir.dx;
                    const newY = org.y + randomDir.dy;
                    
                    // Check if valid position
                    if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                        const tile = grid[newY][newX];
                        if (tile.groundLayer === null) {
                            // Check if tile is not already regrowing
                            const isRegrowing = regrowingTiles.some(t => t.x === newX && t.y === newY);
                            if (!isRegrowing) {
                                grassToAdd.push({ x: newX, y: newY });
                            }
                        }
                    }
                }
            });
            
            // Add new grass (both from spreading and regrowth)
            grassToAdd.forEach(pos => {
                const tile = grid[pos.y][pos.x];
                if (tile.groundLayer === null) { // Double check it's still empty
                    const newGrass = {
                        id: nextId++,
                        type: 'grass',
                        x: pos.x,
                        y: pos.y,
                        spreadTimer: 0,
                        alpha: 0 // Start invisible, fade in
                    };
                    organisms.push(newGrass);
                    tile.groundLayer = newGrass.id;
                    populations.grass++;
                }
            });
        }

        // Rabbit movement and eating
        function updateRabbits(deltaTime) {
            const rabbitsToRemove = [];
            const rabbitsToAdd = [];
            
            organisms.forEach(org => {
                if (org.type !== 'rabbit') return;
                
                // Smooth movement animation
                const moveSpeed = 5; // tiles per second for visual movement
                if (org.visualX < org.x) {
                    org.visualX = Math.min(org.x, org.visualX + deltaTime * moveSpeed);
                } else if (org.visualX > org.x) {
                    org.visualX = Math.max(org.x, org.visualX - deltaTime * moveSpeed);
                }
                if (org.visualY < org.y) {
                    org.visualY = Math.min(org.y, org.visualY + deltaTime * moveSpeed);
                } else if (org.visualY > org.y) {
                    org.visualY = Math.max(org.y, org.visualY - deltaTime * moveSpeed);
                }
                
                // Update trail
                if (org.trail) {
                    // Add current position to trail
                    if (org.trail.length === 0 || 
                        org.trail[org.trail.length - 1].x !== org.x || 
                        org.trail[org.trail.length - 1].y !== org.y) {
                        org.trail.push({ x: org.visualX, y: org.visualY, alpha: 0.3 });
                    }
                    
                    // Fade out trail
                    org.trail.forEach(point => {
                        point.alpha = Math.max(0, point.alpha - deltaTime * 0.5);
                    });
                    
                    // Remove invisible trail points
                    org.trail = org.trail.filter(point => point.alpha > 0.01);
                    
                    // Limit trail length
                    if (org.trail.length > 10) {
                        org.trail.shift();
                    }
                }
                
                // Fade in new rabbits
                if (org.alpha < 1) {
                    org.alpha = Math.min(1, org.alpha + deltaTime * 3); // Fade in over 0.33 seconds
                }
                
                // Update hunger
                org.hungerTimer += deltaTime;
                
                // Update lifespan
                org.lifeTimer += deltaTime;
                
                // Update reproduction timer
                org.reproductionTimer += deltaTime;
                
                // Fade out before death
                if (org.lifeTimer >= 78 || org.hungerTimer >= 10) {
                    org.alpha = Math.max(0, org.alpha - deltaTime * 2); // Fade out over 0.5 seconds
                }
                
                // Die from old age at 80 seconds
                if (org.lifeTimer >= 80) {
                    rabbitsToRemove.push(org.id);
                    return;
                }
                
                // Starve at 12 seconds
                if (org.hungerTimer >= 12) {
                    rabbitsToRemove.push(org.id);
                    return;
                }
                
                // Reproduction (every 20 seconds when well-fed)
                if (org.reproductionTimer >= 20 && org.hungerTimer < 6) {
                    org.reproductionTimer = 0;
                    
                    // Find adjacent empty tile
                    const directions = [
                        {dx: -1, dy: -1}, {dx: 0, dy: -1}, {dx: 1, dy: -1},
                        {dx: -1, dy: 0},                   {dx: 1, dy: 0},
                        {dx: -1, dy: 1},  {dx: 0, dy: 1},  {dx: 1, dy: 1}
                    ];
                    
                    // Shuffle directions
                    const shuffled = directions.sort(() => Math.random() - 0.5);
                    
                    for (let dir of shuffled) {
                        const newX = org.x + dir.dx;
                        const newY = org.y + dir.dy;
                        
                        if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                            const tile = grid[newY][newX];
                            if (tile.animalLayer === null) {
                                // Space available - reproduce
                                rabbitsToAdd.push({ x: newX, y: newY });
                                break;
                            }
                        }
                    }
                }
                
                // Movement (2 tiles per second)
                org.moveTimer += deltaTime;
                const moveInterval = 0.5; // Move every 0.5 seconds
                
                if (org.moveTimer >= moveInterval) {
                    org.moveTimer = 0;
                    
                    // Find nearest grass within 3 tiles
                    let nearestGrass = null;
                    let nearestDist = 3;
                    
                    if (org.hungerTimer > 6) { // Only search if hungry
                        organisms.forEach(other => {
                            if (other.type !== 'grass') return;
                            const dist = Math.abs(other.x - org.x) + Math.abs(other.y - org.y);
                            if (dist <= 3 && dist < nearestDist) {
                                nearestGrass = other;
                                nearestDist = dist;
                            }
                        });
                    }
                    
                    // Move toward grass or random
                    let newX = org.x;
                    let newY = org.y;
                    
                    if (nearestGrass) {
                        // Move toward grass
                        if (nearestGrass.x > org.x) newX++;
                        else if (nearestGrass.x < org.x) newX--;
                        else if (nearestGrass.y > org.y) newY++;
                        else if (nearestGrass.y < org.y) newY--;
                    } else {
                        // Random movement
                        const dir = Math.floor(Math.random() * 4);
                        if (dir === 0) newX++;
                        else if (dir === 1) newX--;
                        else if (dir === 2) newY++;
                        else newY--;
                    }
                    
                    // Clamp to grid
                    newX = Math.max(0, Math.min(GRID_SIZE - 1, newX));
                    newY = Math.max(0, Math.min(GRID_SIZE - 1, newY));
                    
                    // Check if destination is free OR has a well-fed fox (can pass through)
                    const targetTile = grid[newY][newX];
                    let canMove = false;
                    
                    if (targetTile.animalLayer === null || targetTile.animalLayer === org.id) {
                        canMove = true;
                    } else {
                        // Check if it's a well-fed fox (recently ate)
                        const occupantId = targetTile.animalLayer;
                        const occupant = organisms.find(o => o.id === occupantId);
                        if (occupant && occupant.type === 'fox' && occupant.hungerTimer < 5) {
                            // Fox just ate (within 5 seconds) - rabbit can pass through!
                            canMove = true;
                        }
                    }
                    
                    if (canMove) {
                        // Move rabbit
                        grid[org.y][org.x].animalLayer = null;
                        org.x = newX;
                        org.y = newY;
                        
                        // Only occupy tile if it's empty
                        if (targetTile.animalLayer === null) {
                            grid[newY][newX].animalLayer = org.id;
                        }
                        
                        // Check if there's grass here - eat it!
                        if (targetTile.groundLayer !== null) {
                            const grassId = targetTile.groundLayer;
                            const grassIndex = organisms.findIndex(o => o.id === grassId);
                            if (grassIndex !== -1) {
                                organisms.splice(grassIndex, 1);
                                targetTile.groundLayer = null;
                                populations.grass--;
                                org.hungerTimer = 0; // Reset hunger
                                
                                // Mark tile for regrowth after 15 seconds
                                regrowingTiles.push({ x: newX, y: newY, timer: 0 });
                            }
                        }
                    }
                }
            });
            
            // Add baby rabbits
            rabbitsToAdd.forEach(pos => {
                const newRabbit = {
                    id: nextId++,
                    type: 'rabbit',
                    x: pos.x,
                    y: pos.y,
                    visualX: pos.x,
                    visualY: pos.y,
                    hungerTimer: 0,
                    lifeTimer: 0,
                    moveTimer: 0,
                    reproductionTimer: 0,
                    targetX: pos.x,
                    targetY: pos.y,
                    alpha: 0, // Start invisible, fade in
                    trail: []
                };
                organisms.push(newRabbit);
                grid[pos.y][pos.x].animalLayer = newRabbit.id;
                populations.rabbits++;
            });
            
            // Remove dead rabbits
            rabbitsToRemove.forEach(id => {
                const index = organisms.findIndex(o => o.id === id);
                if (index !== -1) {
                    const rabbit = organisms[index];
                    grid[rabbit.y][rabbit.x].animalLayer = null;
                    organisms.splice(index, 1);
                    populations.rabbits--;
                }
            });
        }

        // Fox hunting and movement
        function updateFoxes(deltaTime) {
            const foxesToRemove = [];
            const foxesToAdd = [];
            
            organisms.forEach(org => {
                if (org.type !== 'fox') return;
                
                // Smooth movement animation
                const moveSpeed = 10; // tiles per second for visual movement (faster than rabbits)
                if (org.visualX < org.x) {
                    org.visualX = Math.min(org.x, org.visualX + deltaTime * moveSpeed);
                } else if (org.visualX > org.x) {
                    org.visualX = Math.max(org.x, org.visualX - deltaTime * moveSpeed);
                }
                if (org.visualY < org.y) {
                    org.visualY = Math.min(org.y, org.visualY + deltaTime * moveSpeed);
                } else if (org.visualY > org.y) {
                    org.visualY = Math.max(org.y, org.visualY - deltaTime * moveSpeed);
                }
                
                // Update trail
                if (org.trail) {
                    // Add current position to trail
                    if (org.trail.length === 0 || 
                        org.trail[org.trail.length - 1].x !== org.x || 
                        org.trail[org.trail.length - 1].y !== org.y) {
                        org.trail.push({ x: org.visualX, y: org.visualY, alpha: 0.4 });
                    }
                    
                    // Fade out trail
                    org.trail.forEach(point => {
                        point.alpha = Math.max(0, point.alpha - deltaTime * 0.6);
                    });
                    
                    // Remove invisible trail points
                    org.trail = org.trail.filter(point => point.alpha > 0.01);
                    
                    // Limit trail length
                    if (org.trail.length > 8) {
                        org.trail.shift();
                    }
                }
                
                // Fade in new foxes
                if (org.alpha < 1) {
                    org.alpha = Math.min(1, org.alpha + deltaTime * 3); // Fade in over 0.33 seconds
                }
                
                // Update hunger
                org.hungerTimer += deltaTime;
                
                // Update lifespan
                org.lifeTimer += deltaTime;
                
                // Update reproduction timer
                org.reproductionTimer += deltaTime;
                
                // Fade out before death
                if (org.lifeTimer >= 158 || org.hungerTimer >= 23) {
                    org.alpha = Math.max(0, org.alpha - deltaTime * 2); // Fade out over 0.5 seconds
                }
                
                // Die from old age at 160 seconds
                if (org.lifeTimer >= 160) {
                    foxesToRemove.push(org.id);
                    return;
                }
                
                // Starve at 25 seconds
                if (org.hungerTimer >= 25) {
                    foxesToRemove.push(org.id);
                    return;
                }
                
                // Reproduction (every 45 seconds when well-fed and prey nearby)
                if (org.reproductionTimer >= 45 && org.hungerTimer < 10) {
                    // Check for nearby rabbits (at least 3 within 8 tiles)
                    let nearbyRabbits = 0;
                    organisms.forEach(other => {
                        if (other.type !== 'rabbit') return;
                        const dist = Math.max(Math.abs(other.x - org.x), Math.abs(other.y - org.y));
                        if (dist <= 8) nearbyRabbits++;
                    });
                    
                    if (nearbyRabbits >= 3) {
                        org.reproductionTimer = 0;
                        
                        // Find adjacent empty tile
                        const directions = [
                            {dx: -1, dy: -1}, {dx: 0, dy: -1}, {dx: 1, dy: -1},
                            {dx: -1, dy: 0},                   {dx: 1, dy: 0},
                            {dx: -1, dy: 1},  {dx: 0, dy: 1},  {dx: 1, dy: 1}
                        ];
                        
                        const shuffled = directions.sort(() => Math.random() - 0.5);
                        
                        for (let dir of shuffled) {
                            const newX = org.x + dir.dx;
                            const newY = org.y + dir.dy;
                            
                            if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                                const tile = grid[newY][newX];
                                if (tile.animalLayer === null) {
                                    foxesToAdd.push({ x: newX, y: newY });
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Movement (4 tiles per second - twice as fast as rabbits)
                org.moveTimer += deltaTime;
                const moveInterval = 0.25; // Move every 0.25 seconds
                
                if (org.moveTimer >= moveInterval) {
                    org.moveTimer = 0;
                    
                    // Find nearest rabbit within 5 tiles
                    let nearestRabbit = null;
                    let nearestDist = 5;
                    
                    if (org.hungerTimer > 10) { // Only hunt if hungry
                        organisms.forEach(other => {
                            if (other.type !== 'rabbit') return;
                            const dist = Math.max(Math.abs(other.x - org.x), Math.abs(other.y - org.y));
                            if (dist <= 5 && dist < nearestDist) {
                                nearestRabbit = other;
                                nearestDist = dist;
                            }
                        });
                    }
                    
                    // Move toward rabbit or random
                    let newX = org.x;
                    let newY = org.y;
                    
                    if (nearestRabbit) {
                        // Chase rabbit
                        if (nearestRabbit.x > org.x) newX++;
                        else if (nearestRabbit.x < org.x) newX--;
                        else if (nearestRabbit.y > org.y) newY++;
                        else if (nearestRabbit.y < org.y) newY--;
                    } else {
                        // Random patrol
                        const dir = Math.floor(Math.random() * 4);
                        if (dir === 0) newX++;
                        else if (dir === 1) newX--;
                        else if (dir === 2) newY++;
                        else newY--;
                    }
                    
                    // Clamp to grid
                    newX = Math.max(0, Math.min(GRID_SIZE - 1, newX));
                    newY = Math.max(0, Math.min(GRID_SIZE - 1, newY));
                    
                    // Check if destination has rabbit or is free
                    const targetTile = grid[newY][newX];
                    
                    if (targetTile.animalLayer !== null && targetTile.animalLayer !== org.id) {
                        // Check if it's a rabbit - eat it!
                        const preyId = targetTile.animalLayer;
                        const preyIndex = organisms.findIndex(o => o.id === preyId);
                        if (preyIndex !== -1 && organisms[preyIndex].type === 'rabbit') {
                            // Eat the rabbit
                            organisms.splice(preyIndex, 1);
                            populations.rabbits--;
                            org.hungerTimer = 0; // Reset hunger
                            
                            // Move fox to that tile
                            grid[org.y][org.x].animalLayer = null;
                            org.x = newX;
                            org.y = newY;
                            grid[newY][newX].animalLayer = org.id;
                        }
                    } else if (targetTile.animalLayer === null) {
                        // Move fox to empty tile
                        grid[org.y][org.x].animalLayer = null;
                        org.x = newX;
                        org.y = newY;
                        grid[newY][newX].animalLayer = org.id;
                    }
                }
            });
            
            // Add baby foxes
            foxesToAdd.forEach(pos => {
                const newFox = {
                    id: nextId++,
                    type: 'fox',
                    x: pos.x,
                    y: pos.y,
                    visualX: pos.x,
                    visualY: pos.y,
                    hungerTimer: 0,
                    lifeTimer: 0,
                    moveTimer: 0,
                    reproductionTimer: 0,
                    alpha: 0, // Start invisible, fade in
                    trail: []
                };
                organisms.push(newFox);
                grid[pos.y][pos.x].animalLayer = newFox.id;
                populations.foxes++;
            });
            
            // Remove dead foxes
            foxesToRemove.forEach(id => {
                const index = organisms.findIndex(o => o.id === id);
                if (index !== -1) {
                    const fox = organisms[index];
                    grid[fox.y][fox.x].animalLayer = null;
                    organisms.splice(index, 1);
                    populations.foxes--;
                }
            });
        }

        // Calculate ecosystem balance
        function calculateBalance() {
            // Ideal ratios: 10 grass : 5 rabbits : 2.5 foxes
            // Normalize to percentages
            const total = populations.grass + populations.rabbits + populations.foxes;
            if (total === 0) return 0;
            
            const grassPercent = (populations.grass / total) * 100;
            const rabbitPercent = (populations.rabbits / total) * 100;
            const foxPercent = (populations.foxes / total) * 100;
            
            // Ideal percentages (10:5:2.5 = 57%:29%:14%)
            const idealGrass = 57;
            const idealRabbit = 29;
            const idealFox = 14;
            
            // Calculate deviation from ideal
            const grassDev = Math.abs(grassPercent - idealGrass);
            const rabbitDev = Math.abs(rabbitPercent - idealRabbit);
            const foxDev = Math.abs(foxPercent - idealFox);
            
            const avgDeviation = (grassDev + rabbitDev + foxDev) / 3;
            const balance = Math.max(0, 100 - avgDeviation);
            
            return Math.round(balance);
        }
        function gameLoop(timestamp) {
            if (gameState !== 'playing' || isPaused) {
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }
            
            // Calculate delta time
            const deltaTime = lastFrameTime === 0 ? 0 : (timestamp - lastFrameTime) / 1000;
            lastFrameTime = timestamp;
            
            // Apply speed multiplier
            const adjustedDelta = deltaTime * simulationSpeed;
            
            // Update time
            timeElapsed += adjustedDelta;
            currentDay = Math.floor(timeElapsed / dayDuration);
            
            // Update time display
            const minutes = Math.floor(timeElapsed / 60);
            const seconds = Math.floor(timeElapsed % 60);
            document.getElementById('timeElapsed').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('currentDay').textContent = Math.min(currentDay, 100);
            
            // Update balance indicator
            const balance = calculateBalance();
            const balanceEl = document.getElementById('balance');
            balanceEl.textContent = balance + '%';
            balanceEl.className = 'balance-value';
            if (balance >= 70) balanceEl.classList.add('balance-healthy');
            else if (balance >= 40) balanceEl.classList.add('balance-warning');
            else balanceEl.classList.add('balance-danger');
            
            // Check win condition
            if (currentDay >= 100 && populations.grass > 0 && populations.rabbits > 0 && populations.foxes > 0) {
                alert('🏆 Victory! Your ecosystem survived 100 days with all three species!');
                gameState = 'setup';
                document.body.classList.remove('simulation-running');
                return;
            }
            
            // Check loss condition
            if (populations.grass === 0 || populations.rabbits === 0 || populations.foxes === 0) {
                let lossReason = '';
                if (populations.grass === 0) lossReason = 'All grass died!';
                else if (populations.rabbits === 0) lossReason = 'All rabbits died!';
                else if (populations.foxes === 0) lossReason = 'All foxes died!';
                
                alert(`💀 Ecosystem Collapsed! ${lossReason}`);
                gameState = 'setup';
                document.body.classList.remove('simulation-running');
                return;
            }
            
            // Update simulation
            updateGrass(adjustedDelta);
            updateRabbits(adjustedDelta);
            updateFoxes(adjustedDelta);
            
            // Update population display
            updatePopulationDisplay();
            
            // Render
            render();
            
            // Continue loop
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Main render function
        function render() {
            tileSize = setupCanvas();
            drawGrid(tileSize);
            drawOrganisms();
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            render();
        });

        // Initialize
        initGrid();
        render();
        updatePopulationDisplay();
        
        // Start game loop (will only run when gameState is 'playing')
        animationFrameId = requestAnimationFrame(gameLoop);
        
        console.log('✓ Arena initialized');
        console.log('✓ Grid system ready:', GRID_SIZE, 'x', GRID_SIZE);
        console.log('✓ Two-layer system:', grid.length * grid[0].length, 'tiles');
        console.log('✓ UI controls initialized');
        console.log('✓ Game loop started');
    </script>
</body>
</html>
